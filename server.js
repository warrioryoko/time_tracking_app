/* eslint-disable no-param-reassign */
const express = require('express');
const bodyParser = require('body-parser');
const fs = require('fs');
const path = require('path');

const app = express();

const DATA_FILE = path.join(__dirname, 'data.json');
// Run the server on localhost environment port 3000, using the web browser
app.set('port', (process.env.PORT || 3000));
// This is making Express serve static content files directly, with express.static. Since I don't know where the folder will end up,
// I command it to look at the current root directory '/' as the mount path, then point to the Time_Tracker folder where all static assests should be
app.use('/', express.static(path.join(__dirname, 'Time_Tracker')));
// Parses JSON - the JSON will be read in as an unformatted string with no whitespace initially. Using Curl to test the GET HTTP verb confirms this
// This parses JSON back into a JavaScript object that is then directly readable
app.use(bodyParser.json());
// While you could manually parse the body of an incoming HTTP request stream... why?
// let the bodyParser create new Request objects from the incoming stream, and allow ANY kind of data type
// by using the "true" flag with the extended option. I want full objects and arrays to be parsed in the HTTP streams,
// and recognizable by Express.JS as such. Much less of a pain, and easier to test what's being passed with HTTP verb requests using Curl, Postman, etc.
// Let the Node.JS middleware do the lifting
app.use(bodyParser.urlencoded({ extended: true }));


// Express.JS parameters: request, response and next/returned promise, in case that's not clear
app.use((req, res, next) => {
  res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate'); // Using native Node.JS methods to not do wasteful caching
  res.setHeader('Pragma', 'no-cache');
  res.setHeader('Expires', '0');
  next();
});

// Defining that the only allowable HTTP GET request is to return a list of timers
// req: request, res: response, err: error, which, if any, will be logged to the console
app.get('/api/timers', (req, res) => {
  fs.readFile(DATA_FILE, (err, data) => {
    res.setHeader('Cache-Control', 'no-cache');
    res.json(JSON.parse(data));
  });
});

// Defining allowable HTTP POST, that will accept a JSON body with "title", "project", and "id" attributes
// Then, inserts a new timer object into its store
app.post('/api/timers', (req, res) => {
  fs.readFile(DATA_FILE, (err, data) => {
    const timers = JSON.parse(data);
    const newTimer = {
      title: req.body.title,
      project: req.body.project,
      id: req.body.id,
      elapsed: 0,
      runningSince: null, // runningSince is used to calculate the timer time, so set to null on initial definition
    };
    timers.push(newTimer); // Because timers isn't touching state, it's okay to use the .push method

    // In React apps, if the array holds or passes state, it is not acceptable to directly touch it by using .push
    // Or, use a map which creates a COPY of the original object, or object.assign which creates a new one using a copy of
    // the object passed as a parameter
    fs.writeFile(DATA_FILE, JSON.stringify(timers, null, 4), () => {
      res.setHeader('Cache-Control', 'no-cache');
      res.json(timers);
    });
  });
});

// Accepts a JSON body with "id", "start" (a timestamp) attributes; goes through its store and finds the timer with the matching id.
// Okay, so I'm using the uuid npm package, to create v4 node unique ids - and in app.js, I'm assigning each timer uuid.v4()
// so I'm keeping track of each timer object by that. Just because I really do NOT want to mess with matching by other properties
// and have to write inefficient and messy logic to do so. Just make a unique hash at runtime for each object to make comparisons
// and be done with it!
app.post('/api/timers/start', (req, res) => {
  fs.readFile(DATA_FILE, (err, data) => {
    const timers = JSON.parse(data);
    timers.forEach((timer) => {
      if (timer.id === req.body.id) {
        timer.runningSince = req.body.start;
      }
    });
    fs.writeFile(DATA_FILE, JSON.stringify(timers, null, 4), () => {
      res.json({});
    });
  });
});

// Accepts JSON with "id" and "stop" (another timestamp) attributes. Again, goes through its data store
// using the foreach and arrow function to match the unique hash id generated by the uuid library at runtime
// It updates elapsed based on how long the timer has been running, using (stop - runningSince)
// Then, it sets runningSince to null, so the timer doesn't continue running in the background
app.post('/api/timers/stop', (req, res) => {
  fs.readFile(DATA_FILE, (err, data) => {
    const timers = JSON.parse(data);
    timers.forEach((timer) => {
      if (timer.id === req.body.id) {
        const delta = req.body.stop - timer.runningSince;
        timer.elapsed += delta;
        timer.runningSince = null;
      }
    });
    fs.writeFile(DATA_FILE, JSON.stringify(timers, null, 4), () => {
      res.json({});
    });
  });
});

// Takes JSON with "id", "title" and or "project" attributes. Updates "title" and "project" to new attributes.
// I really like using forEach to sort through collections. I'm familiar with C#, which has a forEach
// and Python which has "for 'x' in 'y'" stuff, so I make use of it when I can use ES2015 JavaScript and later
app.put('/api/timers', (req, res) => {
  fs.readFile(DATA_FILE, (err, data) => {
    const timers = JSON.parse(data);
    timers.forEach((timer) => {
      if (timer.id === req.body.id) {
        timer.title = req.body.title;
        timer.project = req.body.project;
      }
    });
    fs.writeFile(DATA_FILE, JSON.stringify(timers, null, 4), () => {
      res.json({});
    });
  });
});

// Does what it says it does: takes JSON with the "id" attribute, sorts through the data store
// then deletes the timer with the matching id. I really appreciate uuid, because it frees me
// from having to match by other properties - which can have all sorts of problems, like duplicates
// or having to manually assign numbers or some sort of scheme... which can run into duplicates or mistakes
// generating and checking a hash at runtime means I don't have to write pages of coded logic
// and instead write much easier documentation explaining why I did what I did
app.delete('/api/timers', (req, res) => {
  fs.readFile(DATA_FILE, (err, data) => {
    let timers = JSON.parse(data);
    timers = timers.reduce((memo, timer) => {
      if (timer.id === req.body.id) {
        return memo;
      } else {
        return memo.concat(timer);
      }
    }, []);
    fs.writeFile(DATA_FILE, JSON.stringify(timers, null, 4), () => {
      res.json({});
    });
  });
});

// For any other requests. How would you even get here? If a get request is received
// that doesn't have a HTTP verb and route defined, just timeout.
app.get('/molasses', (_, res) => {
  setTimeout(() => {
    res.end();
  }, 5000);
});

// Telling Express to listen to whatever port I set at the top, in this case, port 3000
app.listen(app.get('port'), () => {
  console.log(`Find the server at: http://localhost:${app.get('port')}/`); // eslint-disable-line no-console
});
